Clang-format patch
================
diff --git a/lib/Analysis/LoopScheduleDependenceAnalysis.cpp b/lib/Analysis/LoopScheduleDependenceAnalysis.cpp
index 967509d..097a616 100644
--- a/lib/Analysis/LoopScheduleDependenceAnalysis.cpp
+++ b/lib/Analysis/LoopScheduleDependenceAnalysis.cpp
@@ -101,7 +101,7 @@ circt::analysis::LoopScheduleDependenceAnalysis::LoopScheduleDependenceAnalysis(
             commonBlock->findAncestorOpInBlock(*destination);
         if (srcOrAncestor == nullptr || dstOrAncestor == nullptr)
           return;
-        
+
         // Check if the dst or its ancestor is before the src or its ancestor.
         // We want to dst to be before the src to insert iter-iteration deps.
         if ((dist != 0 && dstOrAncestor->isBeforeInBlock(srcOrAncestor)) ||
diff --git a/lib/Conversion/LoopScheduleToCalyx/LoopScheduleToCalyx.cpp b/lib/Conversion/LoopScheduleToCalyx/LoopScheduleToCalyx.cpp
index fe11b01..a0299ab 100644
--- a/lib/Conversion/LoopScheduleToCalyx/LoopScheduleToCalyx.cpp
+++ b/lib/Conversion/LoopScheduleToCalyx/LoopScheduleToCalyx.cpp
@@ -94,8 +94,8 @@ public:
 //===----------------------------------------------------------------------===//
 
 /// A variant of types representing schedulable operations.
-using Schedulable =
-    std::variant<calyx::StaticGroupOp, LoopWrapper, PhaseInterface, LoopScheduleIfOp>;
+using Schedulable = std::variant<calyx::StaticGroupOp, LoopWrapper,
+                                 PhaseInterface, LoopScheduleIfOp>;
 
 using PhaseRegister = std::variant<calyx::RegisterOp, Value>;
 
@@ -313,8 +313,8 @@ class BuildOpGroups : public calyx::FuncOpPartialLoweringPattern {
                   XOrIOp, OrIOp, ExtUIOp, ExtSIOp, TruncIOp, MulIOp, DivUIOp,
                   DivSIOp, RemUIOp, RemSIOp, IndexCastOp, SelectOp,
                   /// loop schedule
-                  LoopInterface, LoopScheduleTerminatorOp,
-                  LoopScheduleYieldOp, LoopScheduleIfOp>(
+                  LoopInterface, LoopScheduleTerminatorOp, LoopScheduleYieldOp,
+                  LoopScheduleIfOp>(
                   [&](auto op) { return buildOp(rewriter, op).succeeded(); })
               .template Case<FuncOp, LoopScheduleRegisterOp, PhaseInterface>(
                   [&](auto) {
@@ -377,8 +377,7 @@ private:
                         LoopScheduleTerminatorOp op) const;
   LogicalResult buildOp(PatternRewriter &rewriter,
                         LoopScheduleYieldOp op) const;
-  LogicalResult buildOp(PatternRewriter &rewriter,
-                        LoopScheduleIfOp op) const;
+  LogicalResult buildOp(PatternRewriter &rewriter, LoopScheduleIfOp op) const;
 
   /// buildLibraryOp will build a TCalyxLibOp inside a TGroupOp based on the
   /// source operation TSrcOp.
@@ -1690,7 +1689,7 @@ class BuildPhaseGroups : public calyx::FuncOpPartialLoweringPattern {
             getState<ComponentLoweringState>().getEvaluatingGroup(value);
         assert(isa<calyx::StaticGroupOp>(evaluatingGroup.value()));
         addBodyGroup(value, dyn_cast<calyx::StaticGroupOp>(
-            evaluatingGroup.value().getOperation()));
+                                evaluatingGroup.value().getOperation()));
         phase->getResult(i).replaceAllUsesWith(*valuePtr);
         auto name =
             getState<ComponentLoweringState>().getUniqueName("phase_reg");
@@ -2206,12 +2205,14 @@ private:
         auto condValue = ifOp.getCond();
         Block *bodyBlock;
         if (phaseOp.isStatic()) {
-          auto ifCtrlOp = rewriter.create<calyx::StaticIfOp>(ifOp.getLoc(), condValue);
+          auto ifCtrlOp =
+              rewriter.create<calyx::StaticIfOp>(ifOp.getLoc(), condValue);
           rewriter.setInsertionPointToEnd(ifCtrlOp.getBodyBlock());
           auto parOp = rewriter.create<calyx::StaticParOp>(ifOp.getLoc());
           bodyBlock = parOp.getBodyBlock();
         } else {
-          auto ifCtrlOp = rewriter.create<calyx::IfOp>(ifOp.getLoc(), condValue);
+          auto ifCtrlOp =
+              rewriter.create<calyx::IfOp>(ifOp.getLoc(), condValue);
           rewriter.setInsertionPointToEnd(ifCtrlOp.getBodyBlock());
           auto parOp = rewriter.create<calyx::ParOp>(ifOp.getLoc());
           bodyBlock = parOp.getBodyBlock();
diff --git a/lib/Conversion/SCFToLoopSchedule/SCFToLoopSchedule.cpp b/lib/Conversion/SCFToLoopSchedule/SCFToLoopSchedule.cpp
index 71d1e5d..930d753 100644
--- a/lib/Conversion/SCFToLoopSchedule/SCFToLoopSchedule.cpp
+++ b/lib/Conversion/SCFToLoopSchedule/SCFToLoopSchedule.cpp
@@ -807,15 +807,17 @@ SCFToLoopSchedule::createLoopSchedulePipeline(scf::ForOp &loop,
       if (predicateMap.contains(op)) {
         Value cond = predicateMap.lookup(op);
         if (stageValueMaps[startTime].contains(cond))
-          cond = stageValueMaps[startTime].lookup(cond); 
-        ifOp = builder.create<LoopScheduleIfOp>(op->getLoc(), op->getResultTypes(), cond);
+          cond = stageValueMaps[startTime].lookup(cond);
+        ifOp = builder.create<LoopScheduleIfOp>(op->getLoc(),
+                                                op->getResultTypes(), cond);
         builder.setInsertionPointToStart(&ifOp.getBody().front());
       }
       auto *newOp = builder.clone(*op, stageValueMaps[startTime]);
       dependenceAnalysis->replaceOp(op, newOp);
       if (predicateMap.contains(op)) {
         if (!newOp->getResults().empty())
-          builder.create<LoopScheduleYieldOp>(op->getLoc(), newOp->getResults());
+          builder.create<LoopScheduleYieldOp>(op->getLoc(),
+                                              newOp->getResults());
         newOp = ifOp;
       }
 
diff --git a/lib/Dialect/LoopSchedule/LoopScheduleOps.cpp b/lib/Dialect/LoopSchedule/LoopScheduleOps.cpp
index a17d32a..52a33e8 100644
--- a/lib/Dialect/LoopSchedule/LoopScheduleOps.cpp
+++ b/lib/Dialect/LoopSchedule/LoopScheduleOps.cpp
@@ -780,7 +780,8 @@ void LoopScheduleAccessOp::print(::mlir::OpAsmPrinter &p) {
 // IfOp
 //===----------------------------------------------------------------------===//
 
-ParseResult LoopScheduleIfOp::parse(OpAsmParser &parser, OperationState &result) {
+ParseResult LoopScheduleIfOp::parse(OpAsmParser &parser,
+                                    OperationState &result) {
   // Create the regions for 'then'.
   result.regions.reserve(1);
   Region *bodyRegion = result.addRegion();
@@ -797,7 +798,8 @@ ParseResult LoopScheduleIfOp::parse(OpAsmParser &parser, OperationState &result)
   // Parse the 'then' region.
   if (parser.parseRegion(*bodyRegion))
     return failure();
-  LoopScheduleIfOp::ensureTerminator(*bodyRegion, parser.getBuilder(), result.location);
+  LoopScheduleIfOp::ensureTerminator(*bodyRegion, parser.getBuilder(),
+                                     result.location);
 
   // Parse the optional attribute list.
   if (parser.parseOptionalAttrDict(result.attributes))
@@ -832,7 +834,8 @@ void LoopScheduleIfOp::build(OpBuilder &odsBuilder, OperationState &odsState,
   Region *thenRegion = odsState.addRegion();
   odsBuilder.createBlock(thenRegion);
   if (resultTypes.empty())
-    LoopScheduleIfOp::ensureTerminator(*thenRegion, odsBuilder, odsState.location);
+    LoopScheduleIfOp::ensureTerminator(*thenRegion, odsBuilder,
+                                       odsState.location);
 }
 
 #include "circt/Dialect/LoopSchedule/LoopScheduleInterfaces.cpp.inc"
================
